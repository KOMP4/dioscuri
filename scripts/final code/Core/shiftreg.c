/*
 * shiftreg.c
 *
 *  Created on: Mar 18, 2023
 *      Author: ilya0
 */

#include <shiftreg.h>

	uint8_t shift_regs_data[3] = {0b00011111, 0b00000000, 0b00011110};  //массив со значениями для сдвиговых регистров
	/*
	 * Описание значений элементов массива shift_regs_data
	 *
	 * 0-ой байт:
	 * 0-ой бит отвечает за CS внешнего устройства, т.е. на плате есть отдельный разъем под spi устройство
	 * 1-ый бит отвечает за WC у EEPROM
	 * 2-ой бит отвечает за CS у BMP280
	 * 3-ий бит отвечает за CS у LIS3MDL
	 * 4-ый бит отвечает за CS у LSM6DSL
	 * 5-7 биты отвечают за мультиплексор
	 *
	 * 1-ый байт:
	 * 0-4 биты отвечают за светодиоды: синий, красный, желтый, зеленый, белый
	 * 5-7 биты отвечают за нераспаенный датчик
	 *
	 * 2-ой байт:
	 * 0-ой бит отвечает за CE на NRF. Этот пин подтянут к питанию NRF через резистор на 10 кОм
	 * 1-ый бит отвечает за CS на NRF. Это пин подтянут к земле через резистор на 10 кОм
	 * 2-ой бит отвечает за подачу питания на NRF. Этот пин подтянут к 3.3 В через резистор на 10 кОм
	 * 3-ий бит отвечает за сброс GPS (надо подтягивать к VDD для работы. Если подать GND, то произойдёт reset)
	 * 4-ый бит отвечает за EN на GPS (надо подтягивать к VDD для работы. Если к GND, то онтперейдёт в режим низкого энергопотребления и работать не будет)
	 * 5 и 6 биты отвечают за пины RF2_1 и RF2_2 (они не используются нами)
	 * 7-ой бит отвечает за светодиод
	 */

void ShiftRegs_init(void)
{
	HAL_GPIO_WritePin(RF_SRE_GPIO_Port, RF_SRE_Pin, 0);  //устанавливаем логический ноль на 13-ых ножках сдвиговых регистров тем самым включаем их выходы
	HAL_GPIO_WritePin(SR0E_GPIO_Port, SR0E_Pin, 0);  //устанавливаем логический ноль на 13-ых ножках сдвиговых регистров тем самым включаем их выходы
	ShiftRegs();
	RF_ShiftRegs();
}

void ShiftRegs(void)  //функция для записи в сдвиговые регистры
{

	uint8_t buf = 0;

	HAL_GPIO_WritePin(SRL_GPIO_Port, SRL_Pin, 0);  //отключаем защёлку

	buf = shift_regs_data[1];
	HAL_SPI_Transmit(&hspi2, &buf, 1, 5000);  //отправляем данные для сдвигового регистра со светодиодами
	//передёргиваем 13-ую ножку
	HAL_GPIO_WritePin(SR0E_GPIO_Port, SR0E_Pin, 1);
	HAL_GPIO_WritePin(SR0E_GPIO_Port, SR0E_Pin, 0);

	buf = shift_regs_data[0];
	HAL_SPI_Transmit(&hspi2, &buf, 1, 5000);  //отправляем данные для сдвигового регистра с датчиками
	//передёргиваем 13-ую ножку
	HAL_GPIO_WritePin(SR0E_GPIO_Port, SR0E_Pin, 1);
	HAL_GPIO_WritePin(SR0E_GPIO_Port, SR0E_Pin, 0);

	HAL_GPIO_WritePin(SRL_GPIO_Port, SRL_Pin, 1);  //включаем защёлку

}

void blue_led(uint8_t flag)  //управление синим светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления синим светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[1] &=~(1<<0);
	else
		shift_regs_data[1] |= 1<<0;
	ShiftRegs();
}

void red_led(uint8_t flag)  //управление красным светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления красным светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[1] &=~(1<<1);
	else
		shift_regs_data[1] |= 1<<1;
	ShiftRegs();
}

void yellow_led(uint8_t flag)  //управление жёлтым светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления жёлтым светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[1] &=~(1<<2);
	else
		shift_regs_data[1] |= 1<<2;
	ShiftRegs();
}

void green_led(uint8_t flag)  //управление зелёным светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления зелёным светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[1] &=~(1<<3);
	else
		shift_regs_data[1] |= 1<<3;
	ShiftRegs();
}

void white_led(uint8_t flag)  //управление белым светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления белым светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[1] &=~(1<<4);
	else
		shift_regs_data[1] |= 1<<4;
	ShiftRegs();
}

void bmp_cs(uint8_t flag)  //управление ножкой CS датчика BMP280
{
	/*
	 * Данная функция нужна для управления ножкой CS датчика BMP280
	 * Если на вход подаётся 0, то на ножке появляется ноль, если другое число, то единица
	 */

	if(flag==0)
		shift_regs_data[0] &=~(1<<2);
	else
		shift_regs_data[0] |= 1<<2;
	ShiftRegs();
}

void lis3mdl_cs(uint8_t flag)  //управление ножкой CS датчика LIS3MDL
{
	/*
	 * Данная функция нужна для управления ножкой CS датчика LIS3MDL
	 * Если на вход подаётся 0, то на ножке появляется ноль, если другое число, то единица
	 */

	if(flag==0)
		shift_regs_data[0] &=~(1<<3);
	else
		shift_regs_data[0] |= 1<<3;
	ShiftRegs();
}

void lsm6ds_cs(uint8_t flag)  //управление ножкой CS датчика lsm6ds
{
	/*
	 * Данная функция нужна для управления ножкой CS датчика lsm6ds
	 * Если на вход подаётся 0, то на ножке появляется ноль, если другое число, то единица
	 */

	if(flag==0)
		shift_regs_data[0] &=~(1<<4);
	else
		shift_regs_data[0] |= 1<<4;
	ShiftRegs();
}



void RF_ShiftRegs(void)  //функция для записи в сдвиговые регистры платы RF
{

		HAL_GPIO_WritePin(RF_SRE_GPIO_Port, RF_SRE_Pin, 1);  //переводим выходы сдвигового регистра в высокоомное состояние, чтобы не влиять передачей данных на nrf
		uint8_t buf;
		HAL_GPIO_WritePin(RF_SRL_GPIO_Port, RF_SRL_Pin, 0);  //отключаем защёлку

		buf = shift_regs_data[2];

		HAL_SPI_Transmit(&hspi2, &buf, 1, 5000);  //отправляем данные для сдвигового регистра со светодиодами

		HAL_GPIO_WritePin(RF_SRL_GPIO_Port, RF_SRL_Pin, 1);  //включаем защёлку
		HAL_GPIO_WritePin(RF_SRE_GPIO_Port, RF_SRE_Pin, 0);  //переводим выходы сдвигового регистра в рабочее состояние

}


void NRF_cs(uint8_t flag)  //управление ножкой CS радиомодуля NRF24L01
{
	/*
	 * Данная функция нужна для управления ножкой CS радиомодуля NRF24L01
	 * Если на вход подаётся 0, то на ножке появляется ноль, если другое число, то единица
	 */

	if(flag==0)
		{
		shift_regs_data[2] &=~(1<<1);
		}
	else
		{
		shift_regs_data[2] |= 1<<1;
		}
	RF_ShiftRegs();
}

void NRF_ce(uint8_t flag)  //управление ножкой CE радиомодуля NRF24L01
{
	/*
	 * Данная функция нужна для управления ножкой CE радиомодуля NRF24L01
	 * Если на вход подаётся 0, то на ножке появляется ноль, если другое число, то единица
	 */

	if(flag==0)
	{
		shift_regs_data[2] &=~(1<<0);
	}

	else
		{
		shift_regs_data[2] |= 1<<0;
		}
	RF_ShiftRegs();
}

void rf_led(uint8_t flag)  //управление синим светодиодом на научной плате
{
	/*
	 * Данная функция нужна для управления синим светодиодом на научной плате
	 * Если на вход подаётся 0, то светодиод выключается, если другое число, то включается
	 */

	if(flag==0)
		shift_regs_data[2] &=~(1<<7);
	else
		shift_regs_data[2] |= 1<<7;
	RF_ShiftRegs();
}

